<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rack Rearrangement Simulation</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Adjust some styling to make the page more visually appealing */
        body {
            background: linear-gradient(to right, #ffffff, #e9ecef);
            font-family: Arial, sans-serif;
        }

        h2, h3 {
            margin-bottom: 10px;
            font-weight: 600;
        }

        .rack-cell {
            border: 3px solid #000;
            height: 60px;
            width: 60px;
            text-align: center;
            cursor: pointer;
            position: relative;
            margin: 5px;
            display: inline-block;
            box-sizing: border-box;
        }

        .goal-background-1 {
            background-color: rgba(255, 99, 71, 0.2);
        }

        .goal-background-2 {
            background-color: rgba(70, 130, 180, 0.2);
        }

        .goal-background-3 {
            background-color: rgba(50, 205, 50, 0.2);
        }

        .goal-background-4 {
            background-color: rgba(255, 235, 59, 0.2);
        }

        .goal-background-5 {
            background-color: rgba(138, 43, 226, 0.2);
        }

        .goal-background-6 {
            background-color: rgba(255, 140, 0, 0.2);
        }

        .tube.selected {
            border: 4px solid #ffcc00;
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.7);
            animation: breathing 1.5s ease-in-out infinite;
        }

        #moveErrorMessage {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #f8d7da;
            color: #721c24;
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            z-index: 1000;
        }

        #successMessage {
            position: fixed;
            top: 60px; /* Positioned below the error message */
            left: 50%;
            transform: translateX(-50%);
            background-color: #d4edda;
            color: #155724;
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        @keyframes breathing {
            0% {
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .tube {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 60%;
            border-radius: 50%;
            z-index: 10;
        }

        .tube.red {
            background-color: #ff6347;
        }

        .tube.blue {
            background-color: #4682b4;
        }

        .tube.green {
            background-color: #32cd32;
        }

        .tube.yellow {
            background-color: #ffeb3b;
        }

        .tube.purple {
            background-color: #8a2be2;
        }

        .tube.orange {
            background-color: #ff8c00;
        }

        .tube.white {
            background-color: white;
        }

        .rack-container {
            display: grid;
            grid-template-columns: repeat(6, 60px);
            grid-template-rows: repeat(4, 60px);
            gap: 5px;
            max-width: 400px;
            margin: 0 auto;
        }

        .btn-primary {
            background-color: #007bff;
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
        }

        .btn-primary:hover {
            background-color: #0056b3;
        }

        /* Highlight for movable tubes */
        .highlight-movable {
            position: relative;
            border: 3px dashed #ffc107;
        }

        .highlight-movable::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-color: rgba(255, 193, 7, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .highlight-destination {
            border: 3px dashed #28a745;
            position: relative;
        }

        .highlight-destination::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-color: rgba(40, 167, 69, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* Additional styling for the thumbnails */
        .thumbnail-grid {
            display: grid;
            grid-template-columns: repeat(6, 12px);
            grid-template-rows: repeat(6, 12px);
            gap: 3px;
            margin-top: 10px;
        }

        .thumbnail-cell {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ccc; /* Default empty cell color */
            position: relative;
        }

        .moved-tube::after {
            content: "";
            position: absolute;
            top: -3px;
            left: -3px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid #f39c12;
            box-sizing: border-box;
        }

        /* Increase the label font size for Before and After */
        .thumbnail-label {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }

        /* Remove move number balloon and adjust styling */
        .move-header {
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
            align-items: flex-start;
        }

        .move-element {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            flex-grow: 1;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .thumbnails-container {
            display: flex;
            gap: 40px;
            margin-top: 20px;
            align-items: center;
            justify-content: center;
        }

        .before-after-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Use smaller circles for tubes to visualize them in the thumbnail */
        .thumbnail-red {
            background-color: #ff6347;
        }

        .thumbnail-blue {
            background-color: #4682b4;
        }

        .thumbnail-green {
            background-color: #32cd32;
        }

        .thumbnail-yellow {
            background-color: #ffeb3b;
        }

        .thumbnail-purple {
            background-color: #8a2be2;
        }

        .thumbnail-orange {
            background-color: #ff8c00;
        }

        /* Tutorial Container */
        .tutorial-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #ffffff;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 20px;
            width: 450px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 100;
            transition: transform 0.3s ease-in-out;
        }

        .tutorial-container.minimized {
            transform: translateY(95%);
        }

        .tutorial-container h4 {
            margin-bottom: 10px;
            font-size: 18px;
        }

        .tutorial-container p {
            font-size: 14px;
            line-height: 1.5;
        }

        .tutorial-toggle {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #ddd;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
        }

        .tutorial-highlight-destination {
            border: 3px dashed #28a745;
            position: relative;
        }

        .tutorial-highlight-destination::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background-color: rgba(40, 167, 69, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .tutorial-highlight-movable {
            position: relative;
            border: 3px dashed #ffc107;
        }

        .tutorial-highlight-movable::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 25px;
            height: 25px;
            background-color: #ff6347;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

    .mask-grid {
        display: grid;
        grid-template-columns: repeat(3, 40px);
        grid-template-rows: repeat(3, 40px);
        gap: 4px;
    }
    .mask-cell {
        position: relative;
        border: 3px solid #0a0a0a;
        width: 40px;
        height: 40px;
        border-radius: 5px;
    }

    .mask-cell-empty {
        border: 3px solid #0a0a0a;
        width: 40px;
        height: 40px;
        border-radius: 5px;
    }

    .mask-cell::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 25px;
            height: 25px;
            background-color: rgba(125, 125, 125, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

    .mask-cell-small {
        position: relative;
        border: 2px solid #0a0a0a;
        width: 25px;
        height: 25px;
        border-radius: 5px;
    }

    .mask-cell-small::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 13px;
            height: 13px;
            background-color: rgba(125, 125, 125, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

    .conditions-container {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
    }
    .condition {
        flex: 1 0 45%;
    }

    </style>
</head>
<body>
<div id="moveErrorMessage">Invalid move!</div>
<div id="successMessage">Congratulations! All tubes are in their goal positions.</div>

<div class="container-fluid">
    <div class="row">
        <!-- Left side: Move history and rewards -->
        <div class="col-md-3" style="margin-top: 20px;">
            <h3 style="margin-bottom: 20px; font-weight: 600;">Move History</h3>
            <div id="historyContainer" style="
                max-height: 500px;
                overflow-y: auto;
                border: 1px solid #ccc;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 5px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <!-- Move history and rewards will be appended here -->
            </div>
        </div>

        <!-- Right side: Existing layout -->
        <div class="col-md-9">
            <div class="container mt-5">
                <h2 class="text-center">Rack Rearrangement</h2>
                <div class="row justify-content-center">
                    <div id="rack-container" class="rack-container">
                        <!-- Grid cells will be inserted here by JavaScript -->
                    </div>
                </div>
                <div class="text-center mt-4">
                    <button class="btn btn-primary" id="resetBtn">Reset to Initial State</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Tutorial Floating Container -->
<div class="tutorial-container" id="tutorialContainer">
    <button class="tutorial-toggle" id="toggleTutorialBtn">Minimize</button>
    <h4>How to Play</h4>
    <p>1. Select a tube to move by clicking on it.<br>
        <!-- Add movable style to the cell for visual guidance -->
        <span class="tutorial-highlight-movable"
              style="display: inline-block; width: 40px; height: 40px; background-color: rgba(0, 0, 0, 0); border-radius: 5px; margin-top:10px;margin-right: 10px;;margin-left: 15px;"></span>
        This cell has a tube and is movable.
    </p>
    <p>2. Choose an empty rack cell to place the tube.<br>
        <!-- Add fillable style to show an empty cell -->
        <span class="tutorial-highlight-destination"
              style="display: inline-block; width: 40px; height: 40px; background-color: rgba(0, 0, 0, 0); border-radius: 5px; margin-top:10px;margin-right: 10px;;margin-left: 15px;"></span>
        This cell is fillable where the tube can be placed.
    </p>
    <p>3. Try to arrange the tubes to match the goal pattern.<br></p>
    <h5>Pick/Place Tube Constraints</h5>
    <p>Only tubes that are in feasible slots can be moved. And only feasible slots can be filled with tubes. <strong>A slot is feasible only if
        one of following conditions is satisfied:</strong></p>
    <!-- Displaying Conditions with Mask Visualizations -->
    <div class="conditions-container">
        <div class="condition">
            <h6>Condition 1:</h6>
            <p><strong>Description:</strong> A slot (at central) is movable/fillable if its surrounding slots are empty along a central vertical axis.</p>
            <div class="mask-grid">
                <div class="mask-cell"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell-empty" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="tutorial-highlight-movable" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell-empty" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell"></div>
            </div>
        </div>
        <div class="condition">
            <h6>Condition 2:</h6>
            <p><strong>Description:</strong> A slot (at central) is movable/fillable if its surrounding slots are empty along a central horizontal axis. </p>
            <div class="mask-grid">
                <div class="mask-cell"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="tutorial-highlight-movable" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell"></div>
            </div>
        </div>
        <div class="condition">
            <h6>Condition 3:</h6>
            <p><strong>Description:</strong> A slot (at central) is movable/fillable if the upper-left corner of its surrounding slots are empty.</p>
            <div class="mask-grid">
                <div class="mask-cell-empty"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell-empty" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="tutorial-highlight-movable" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell"></div>
            </div>
        </div>
        <div class="condition">
            <h6>Condition 4: </h6>
            <p><strong>Description:</strong> A slot (at central) is movable/fillable if the upper-right corner of its surrounding slots are empty.</p>
            <div class="mask-grid">
                <div class="mask-cell-empty"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="tutorial-highlight-movable" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell-empty" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell-empty"></div>
            </div>
        </div>
        <div class="condition">
            <h6>Condition 5: </h6>
            <p><strong>Description:</strong> A slot (at central) is movable/fillable if the bottom-right corner of its surrounding slots are empty.</p>
            <div class="mask-grid">
                <div class="mask-cell"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="tutorial-highlight-movable" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell-empty" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell-empty"></div>
            </div>
        </div>
        <div class="condition">
            <h6>Condition 6: BR</h6>
            <p><strong>Description:</strong> A slot (at central) is movable/fillable if the bottom-left corner of its surrounding slots are empty.</p>
            <div class="mask-grid">
                <div class="mask-cell-empty"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell"></div>
                <div class="mask-cell-empty" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="tutorial-highlight-movable" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell" style="background-color: rgba(0, 0, 0, 0);"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell-empty"></div>
                <div class="mask-cell-empty"></div>
            </div>
        </div>
        <p><strong>Note:</strong> <span class="mask-cell-small" style="display: inline-block;"></span> represents a slot that may contain a tube or be empty.</p>
    </div>
</div>

<script>
    // Toggle tutorial visibility
    document.getElementById('toggleTutorialBtn').addEventListener('click', function () {
        const tutorialContainer = document.getElementById('tutorialContainer');
        tutorialContainer.classList.toggle('minimized');
        this.textContent = tutorialContainer.classList.contains('minimized') ? 'Maximize' : 'Minimize';
    });
    // Movement constraint masks
    const MASKS = {
        UCBC: [[0, 1, 0], [0, 0, 0], [0, 1, 0]],
        CRCL: [[0, 0, 0], [1, 0, 1], [0, 0, 0]],
        UL: [[1, 1, 1], [1, 0, 0], [1, 0, 0]],
        UR: [[1, 1, 1], [0, 0, 1], [0, 0, 1]],
        BL: [[1, 0, 0], [1, 0, 0], [1, 1, 1]],
        BR: [[0, 0, 1], [0, 0, 1], [1, 1, 1]]
    };

    // Implement the reward calculation in JavaScript as described in the Python code
    function isDone(state, goal) {
        for (let i = 0; i < state.length; i++) {
            for (let j = 0; j < state[i].length; j++) {
                if (state[i][j] !== goal[i][j]) {
                    return false;
                }
            }
        }
        return true;
    }

    function getRewardExp(is_finished, state_current, state_next, goal_pattern) {
        // Convert arrays for easier comparison
        // state_current, state_next, goal_pattern are already arrays of arrays
        if (is_finished) {
            if (isDone(state_next, goal_pattern)) {
                return 20;
            } else {
                return -20;
            }
        }

        // Calculate move_map = state_next - state_current
        const move_map = [];
        for (let r = 0; r < state_next.length; r++) {
            move_map[r] = [];
            for (let c = 0; c < state_next[r].length; c++) {
                move_map[r][c] = state_next[r][c] - state_current[r][c];
            }
        }

        // Identify move_from and move_to positions
        let move_from_idx = [];
        let move_to_idx = [];
        for (let r = 0; r < move_map.length; r++) {
            for (let c = 0; c < move_map[r].length; c++) {
                if (move_map[r][c] > 0) {
                    move_to_idx.push([r, c]);
                } else if (move_map[r][c] < 0) {
                    move_from_idx.push([r, c]);
                }
            }
        }

        // Helper function to check patterns
        function checkPattern(idxArray, referenceState, referenceGoal) {
            if (idxArray.length === 0) return false;
            return idxArray.every(([r, c]) => referenceGoal[r][c] === referenceState[r][c]);
        }

        const is_move_to_pattern = checkPattern(move_to_idx, state_next, goal_pattern);
        const is_move_out_pattern = checkPattern(move_from_idx, state_current, goal_pattern);
        let reward = 0;
        if (is_move_to_pattern && !is_move_out_pattern) {
            reward = 1;
        } else if (is_move_out_pattern && !is_move_to_pattern) {
            reward = -2;
        } else {
            reward = -1;
        }
        // move to other goal
        for (let [r, c] of move_to_idx) {
            if (goal_pattern[r][c] > 0 && goal_pattern[r][c] !== state_next[r][c]) {
                reward -= 1;
            }
        }
        // move out of other goal
        if (move_from_idx.length > 0 && move_to_idx.length > 0) {
            for (let [r, c] of move_from_idx) {
                if (goal_pattern[r][c] > 0 && goal_pattern[r][c] !== state_current[r][c]) {
                    let movedToOtherGoal = false;
                    for (let [rr, cc] of move_to_idx) {
                        if (goal_pattern[rr][cc] > 0 && goal_pattern[rr][cc] !== state_next[rr][cc]) {
                            movedToOtherGoal = true;
                            break;
                        }
                    }
                    if (!movedToOtherGoal) {
                        reward += 1;
                    }
                }
            }
        }
        return reward;
    }

    // Add this function within your <script> tag
    function downloadMoveHistory(init_rack, goal_pattern, move_history) {
        const historyData = {
            init: init_rack,
            goal: goal_pattern,
            history: move_history
        };
        // Pretty-printing the JSON with an indentation of 2 spaces
        const dataStr = JSON.stringify(historyData, null, 2);
        const blob = new Blob([dataStr], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        // Creating a download link and triggering the download
        const a = document.createElement('a');
        a.href = url;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        a.download = `move_history_${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        // Revoke the object URL after the download
        URL.revokeObjectURL(url);
    }

    function padMatrix(matrix, padWidth = 2) {
        const padded = Array.from({length: matrix.length + 2 * padWidth}, () =>
            Array(matrix[0].length + 2 * padWidth).fill(0)
        );

        for (let i = 0; i < matrix.length; i++) {
            for (let j = 0; j < matrix[0].length; j++) {
                padded[i + padWidth][j + padWidth] = matrix[i][j];
            }
        }

        return padded;
    }

    function correlate2d(matrix, mask) {
        const paddedMatrix = padMatrix(matrix);
        const result = Array.from({length: matrix.length}, () =>
            Array(matrix[0].length).fill(0)
        );

        for (let i = 0; i < result.length; i++) {
            for (let j = 0; j < result[0].length; j++) {
                let sum = 0;
                for (let mi = 0; mi < mask.length; mi++) {
                    for (let mj = 0; mj < mask[0].length; mj++) {
                        sum += paddedMatrix[i + mi][j + mj] * mask[mi][mj];
                    }
                }
                result[i][j] = sum;
            }
        }

        return result;
    }

    function checkConstraintMask(subMatrix, mask) {
        return mask.every((row, i) =>
            row.every((val, j) =>
                val === 0 || (val === 1 && subMatrix[i][j] === 0)
            )
        );
    }

    function checkGoalCompletion() {
        for (let row = 0; row < initialRack.length; row++) {
            for (let col = 0; col < initialRack[row].length; col++) {
                if (initialRack[row][col] !== goalPattern[row][col]) {
                    return false;
                }
            }
        }
        return true;
    }

    function getSubMatrix(matrix, centerRow, centerCol, maskSize) {
        const offset = Math.floor(maskSize / 2);
        const subMatrix = Array.from({length: maskSize}, () => Array(maskSize).fill(0));

        for (let i = 0; i < maskSize; i++) {
            for (let j = 0; j < maskSize; j++) {
                const row = centerRow + i - offset;
                const col = centerCol + j - offset;

                if (row >= 0 && row < matrix.length && col >= 0 && col < matrix[0].length) {
                    subMatrix[i][j] = matrix[row][col];
                }
            }
        }

        return subMatrix;
    }

    function getMovementConstraints(node, selectedTube) {
        const masks = [
            {name: 'UCBC', mask: [[0, 1, 0], [0, 0, 0], [0, 1, 0]]},
            {name: 'CRCL', mask: [[0, 0, 0], [1, 0, 1], [0, 0, 0]]},
            {name: 'UL', mask: [[1, 1, 1], [1, 0, 0], [1, 0, 0]]},
            {name: 'UR', mask: [[1, 1, 1], [0, 0, 1], [0, 0, 1]]},
            {name: 'BL', mask: [[1, 0, 0], [1, 0, 0], [1, 1, 1]]},
            {name: 'BR', mask: [[0, 0, 1], [0, 0, 1], [1, 1, 1]]}
        ];

        const modifiedNode = node.map(row => [...row]);
        if (selectedTube) {
            modifiedNode[selectedTube[0]][selectedTube[1]] = 0;
        }

        const movableCells = [];
        const fillableCells = [];

        for (let row = 0; row < modifiedNode.length; row++) {
            for (let col = 0; col < modifiedNode[row].length; col++) {
                if (modifiedNode[row][col] !== 0) {
                    const isMovable = masks.some(({mask}) => {
                        const subMatrix = getSubMatrix(modifiedNode, row, col, mask.length);
                        return checkConstraintMask(subMatrix, mask);
                    });

                    if (isMovable) movableCells.push([row, col]);
                } else {
                    const isFilable = masks.some(({mask}) => {
                        const subMatrix = getSubMatrix(modifiedNode, row, col, mask.length);
                        return checkConstraintMask(subMatrix, mask);
                    });

                    if (isFilable) fillableCells.push([row, col]);
                }
            }
        }

        return {movableCells, fillableCells};
    }

    let initialRackList = [];
    let goalPatternList = [];

    //// Fetch JSON files for initialRack and goalPattern from GitHub
    function fetchDataFromGitHub() {
        const initialRackUrl = 'https://raw.githubusercontent.com/chenhaox/rearrangetube/refs/heads/main/state_list.json';
        const goalPatternUrl = 'https://raw.githubusercontent.com/chenhaox/rearrangetube/refs/heads/main/goal_list.json';

        Promise.all([fetch(initialRackUrl), fetch(goalPatternUrl)])
            .then(responses => Promise.all(responses.map(response => response.json())))
            .then(([initialRackData, goalPatternData]) => {
                initialRackList = initialRackData;
                goalPatternList = goalPatternData;
                const randomRackIndex = Math.floor(Math.random() * initialRackList.length);
                const randomGoalIndex = Math.floor(Math.random() * goalPatternList.length);
                initialRack = initialRackData[randomRackIndex];
                goalPattern = goalPatternData[randomGoalIndex];
                renderRack();
            })
            .catch(error => {
                console.error('Error fetching data from GitHub:', error);
            });
    }

    fetchDataFromGitHub(); // Call this function when you want to load the data
    // Add this near the existing variables
    let moveHistory = [];

    const tubeColors = {
        0: null,
        1: 'red',
        2: 'blue',
        3: 'green',
        4: 'yellow',
        5: 'purple',
        6: 'orange'
    };

    let selectedCell = null;

    function createTube(color) {
        const tube = document.createElement('div');
        tube.classList.add('tube', color);
        return tube;
    }

    function showErrorMessage() {
        const errorMessage = document.getElementById('moveErrorMessage');
        errorMessage.style.display = 'block';
        setTimeout(() => {
            errorMessage.style.display = 'none';
        }, 2000);
    }

    function renderRack() {
        const rackContainer = document.getElementById('rack-container');
        rackContainer.innerHTML = '';

        // Determine movable tubes before selection
        const preSelectionMovableCells = getMovementConstraints(initialRack).movableCells;

        for (let row = 0; row < initialRack.length; row++) {
            for (let col = 0; col < initialRack[row].length; col++) {
                const cell = document.createElement('div');
                cell.classList.add('rack-cell');

                // Goal pattern background
                if (goalPattern[row][col] !== 0) {
                    cell.classList.add(`goal-background-${goalPattern[row][col]}`);
                }

                // Pre-selection highlighting for movable tubes
                const isPreSelectionMovableCell = preSelectionMovableCells.some(
                    ([r, c]) => r === row && c === col
                );
                if (isPreSelectionMovableCell) {
                    cell.classList.add('highlight-movable');
                }

                // Constraints after selection
                let constraints = {movableCells: [], fillableCells: []};
                if (selectedCell) {
                    constraints = getMovementConstraints(initialRack, selectedCell);

                    const isMovableCell = constraints.movableCells.some(
                        ([r, c]) => r === row && c === col
                    );
                    const isFillableCell = constraints.fillableCells.some(
                        ([r, c]) => r === row && c === col
                    );

                    if (isMovableCell) cell.classList.add('highlight-movable');
                    if (isFillableCell) cell.classList.add('highlight-destination');
                }

                cell.setAttribute('data-row', row);
                cell.setAttribute('data-col', col);

                if (initialRack[row][col] !== 0) {
                    const tube = createTube(tubeColors[initialRack[row][col]]);
                    cell.appendChild(tube);
                }

                cell.addEventListener('click', () => cellClickHandler(row, col));

                if (selectedCell && selectedCell[0] === row && selectedCell[1] === col) {
                    const tube = cell.querySelector('.tube');
                    if (tube) {
                        tube.classList.add('selected');
                    }
                }

                rackContainer.appendChild(cell);
            }
        }
    }

    function cellClickHandler(row, col) {
        const constraints = getMovementConstraints(initialRack, selectedCell);

        if (!selectedCell) {
            // Check if the selected cell is a movable cell
            const isMovableCell = constraints.movableCells.some(
                ([r, c]) => r === row && c === col
            );

            if (isMovableCell && initialRack[row][col] !== 0) {
                selectedCell = [row, col];
                renderRack();
            }
        } else {
            const [selRow, selCol] = selectedCell;

            // If clicking the same cell, deselect
            if (selRow === row && selCol === col) {
                selectedCell = null;
                renderRack();
                return;
            }

            // Check if the target cell is a valid fillable cell
            const isValidMove = constraints.fillableCells.some(
                ([r, c]) => r === row && c === col
            );

            if (isValidMove) {
                // Save a copy of the current state before making the move for reward calculation
                const state_current = JSON.parse(JSON.stringify(initialRack));
                // Move the tube
                initialRack[row][col] = initialRack[selRow][selCol];
                initialRack[selRow][selCol] = 0;
                const state_next = JSON.parse(JSON.stringify(initialRack));
                // Compute reward
                const finished = isDone(initialRack, goalPattern);
                const reward = getRewardExp(finished, state_current, state_next, goalPattern);
                // Record the move
                const moveRecord = {
                    from: {row: selRow, col: selCol},
                    to: {row: row, col: col},
                    timestamp: new Date().toISOString(),
                    stateBefore: state_current,
                    stateAfter: state_next
                };
                moveHistory.push(moveRecord);
                updateHistoryUI(moveRecord);
                // Check for goal completion
                if (finished) {
                    const successMessage = document.getElementById('successMessage');
                    successMessage.style.display = 'block';
                    setTimeout(() => {
                        successMessage.style.display = 'none';
                    }, 3000); // Display for 3 seconds
                    downloadMoveHistory(initialRack, goalPattern, moveHistory); // Trigger the download
                    // Clear moveHistory after downloading
                    moveHistory = [];
                }
                selectedCell = null;
                previousRack = JSON.parse(JSON.stringify(initialRack));
                renderRack();
            } else {
                showErrorMessage();
            }
        }
    }

    // Modify createThumbnail to highlight moved tubes
    function createThumbnail(state, highlightFrom, highlightTo) {
        const tubeColors = {
            0: null,
            1: 'red',
            2: 'blue',
            3: 'green',
            4: 'yellow',
            5: 'purple',
            6: 'orange'
        };

        const thumbnail = document.createElement('div');
        thumbnail.classList.add('thumbnail-grid');

        for (let r = 0; r < state.length; r++) {
            for (let c = 0; c < state[r].length; c++) {
                const cellValue = state[r][c];
                const cellDiv = document.createElement('div');
                cellDiv.classList.add('thumbnail-cell');
                if (cellValue !== 0) {
                    cellDiv.classList.add(`thumbnail-${tubeColors[cellValue]}`);
                }

                // Highlight if this cell is the from or to position
                if ((highlightFrom && highlightFrom.row === r && highlightFrom.col === c) ||
                    (highlightTo && highlightTo.row === r && highlightTo.col === c)) {
                    cellDiv.classList.add('moved-tube');
                }

                thumbnail.appendChild(cellDiv);
            }
        }

        return thumbnail;
    }


    // Add a function to update the History UI
    // Update the updateHistoryUI function to remove the index and enlarge the Before/After thumbnails
    // Update the updateHistoryUI function to place before/after thumbnails inside the moveElement div
    function updateHistoryUI(moveRecord) {
        const historyContainer = document.getElementById('historyContainer');

        const moveWrapper = document.createElement('div');
        moveWrapper.style.display = 'flex';
        moveWrapper.style.flexDirection = 'column';
        moveWrapper.style.marginBottom = '20px';

        const moveHeader = document.createElement('div');
        moveHeader.classList.add('move-header');

        const moveElement = document.createElement('div');
        moveElement.classList.add('move-element');
        moveElement.innerHTML = `
            From: (${moveRecord.from.row}, ${moveRecord.from.col})<br>
            To: (${moveRecord.to.row}, ${moveRecord.to.col})<br>
            <small>${moveRecord.timestamp}</small>
        `;

        // Thumbnails container for before and after states, merged with the moveElement div
        const thumbnailsContainer = document.createElement('div');
        thumbnailsContainer.classList.add('thumbnails-container');

        const beforeWrapper = document.createElement('div');
        beforeWrapper.classList.add('before-after-wrapper');
        const beforeLabel = document.createElement('div');
        beforeLabel.textContent = 'Before';
        beforeLabel.classList.add('thumbnail-label');
        beforeWrapper.appendChild(beforeLabel);
        beforeWrapper.appendChild(createThumbnail(moveRecord.stateBefore, moveRecord.from, null));

        const afterWrapper = document.createElement('div');
        afterWrapper.classList.add('before-after-wrapper');
        const afterLabel = document.createElement('div');
        afterLabel.textContent = 'After';
        afterLabel.classList.add('thumbnail-label');
        afterWrapper.appendChild(afterLabel);
        afterWrapper.appendChild(createThumbnail(moveRecord.stateAfter, null, moveRecord.to));

        thumbnailsContainer.appendChild(beforeWrapper);
        thumbnailsContainer.appendChild(afterWrapper);

        moveElement.appendChild(thumbnailsContainer);
        moveHeader.appendChild(moveElement);

        moveWrapper.appendChild(moveHeader);
        historyContainer.appendChild(moveWrapper);
    }

    document.getElementById('resetBtn').addEventListener('click', function () {
        selectedCell = null;

        // Reset the rack to the initial state
        document.getElementById('resetBtn').addEventListener('click', function () {
            selectedCell = null;

            // Check if data is loaded
            if (!initialRackList || initialRackList.length === 0 || !goalPatternList || goalPatternList.length === 0) {
                console.error('Data not loaded yet');
                showErrorMessage('Data not loaded yet');
                return;
            }

            // Select random indices
            const randomRackIndex = Math.floor(Math.random() * initialRackList.length);
            const randomGoalIndex = Math.floor(Math.random() * goalPatternList.length);

            // Update initial and goal patterns
            initialRack = initialRackList[randomRackIndex];
            goalPattern = goalPatternList[randomGoalIndex];

            renderRack();

            // Reset move history
            moveHistory = [];
            const historyContainer = document.getElementById('historyContainer');
            if (historyContainer) {
                historyContainer.innerHTML = '';
            }
            console.log('Move History Reset');
        });
    });
    renderRack();
</script>
</body>
</html>